on:
  workflow_call:
    inputs:
      environment:
        description: "Target environment (dev, uat, prod)"
        required: true
        type: string
      docker_image_name:
        description: "Docker image name (for cleanup)"
        required: true
        type: string
      is_ui_app:
        description: "Whether the app is a UI app"
        required: false
        type: boolean
        default: false
      app_path:
        description: "Path to the application directory (relative to repo root). Defaults to root."
        required: false
        type: string
        default: "."
    secrets:
      IAM_ROLE_ARN:
        description: "AWS IAM Role ARN for OIDC authentication"
        required: true
      EC2_INSTANCE_ID:
        description: "Target EC2 Instance ID"
        required: true
      AWS_SECRETS_ARN:
        description: "AWS Secrets Manager ARN"
        required: false

jobs:
  start-container:
    name: Start Docker Container on EC2
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      AWS_REGION: ap-south-1
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      IAM_ROLE_ARN: ${{ secrets.IAM_ROLE_ARN }}
      PORT_MAPPING: ${{ vars.PORT_MAPPING }}
      UI_PORT_MAPPING: ${{ vars.UI_PORT_MAPPING }}
      CLOUDWATCH_LOG_GROUP: ${{ vars.CLOUDWATCH_LOG_GROUP }}
      CLOUDWATCH_LOG_STREAM: ${{ vars.CLOUDWATCH_LOG_STREAM }}
      AWS_SECRETS_ARN: ${{ secrets.AWS_SECRETS_ARN }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout sgx-github-actions workflow repository
        uses: actions/checkout@v4
        with:
          repository: Ennovative-Genix/sgx-github-actions
          ref: main
          sparse-checkout: .github/scripts
          sparse-checkout-cone-mode: false
          path: workflow-repo

      - name: Make poll-ssm-command.sh executable
        run: chmod +x workflow-repo/.github/scripts/poll-ssm-command.sh

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-EC2-Start-Container-${{ github.run_id }}

      - name: Fetch .env from AWS Secrets Manager
        if: ${{ env.AWS_SECRETS_ARN != '' }}
        run: |
          aws secretsmanager get-secret-value \
            --secret-id ${{ env.AWS_SECRETS_ARN }} \
            --region ap-south-1 \
            --query 'SecretString' \
            --output text > .env
          echo ".env file fetched from AWS Secrets Manager"

      - name: Copy .env to EC2 Instance
        if: ${{ env.AWS_SECRETS_ARN != '' }}
        run: |
          ENV_CONTENT=$(cat .env | base64 | tr -d '\n')
          COMMAND="echo $ENV_CONTENT | base64 -d > /var/tmp/.env"
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"$COMMAND\"]}" \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Copy .env to EC2 Instance"

      - name: Copy docker-compose.client.yml to EC2 Instance
        if: ${{ inputs.is_ui_app == true }}
        run: |
          COMPOSE_CONTENT=$(cat ${{ inputs.app_path }}/docker-compose.client.yml | base64 | tr -d '\n')
          COMMAND="echo $COMPOSE_CONTENT | base64 -d > /var/tmp/docker-compose.yml"
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"$COMMAND\"]}" \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Copy docker-compose.yml"

      - name: Copy docker-compose.server.yml to EC2 Instance
        if: ${{ inputs.is_ui_app == false }}
        run: |
          COMPOSE_CONTENT=$(cat ${{ inputs.app_path }}/docker-compose.server.yml | base64 | tr -d '\n')
          COMMAND="echo $COMPOSE_CONTENT | base64 -d > /var/tmp/docker-compose.yml"
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"$COMMAND\"]}" \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Copy docker-compose.yml"

      - name: Stop existing Docker container
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":["cd /var/tmp && docker compose down || true"]}' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Stop Docker Container"

      - name: Start Docker container
        run: |
          if [ "${{ inputs.is_ui_app }}" == "true" ]; then
            SELECTED_PORT_MAPPING="${{ env.UI_PORT_MAPPING }}"
          else
            SELECTED_PORT_MAPPING="${{ env.PORT_MAPPING }}"
          fi
          if [ "${{ vars.CLOUDWATCH_LOG_GROUP }}" != "" ]; then
            CLOUDWATCH_LOG_GROUP_PARAM="${{ vars.CLOUDWATCH_LOG_GROUP }}"
            CLOUDWATCH_LOG_STREAM_PARAM="${{ vars.CLOUDWATCH_LOG_STREAM }}"
          else
            CLOUDWATCH_LOG_GROUP_PARAM=""
            CLOUDWATCH_LOG_STREAM_PARAM=""
          fi
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[\"cd /var/tmp && PORT_MAPPING=${SELECTED_PORT_MAPPING} IMAGE_NAME=${{ inputs.docker_image_name }} AWS_REGION=${{ env.AWS_REGION }} CLOUDWATCH_LOG_GROUP=${CLOUDWATCH_LOG_GROUP_PARAM} CLOUDWATCH_LOG_STREAM=${CLOUDWATCH_LOG_STREAM_PARAM} docker compose up -d\"]}" \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Start Docker Container"

      - name: Clean up tar file
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":["rm -f /var/tmp/${{ inputs.docker_image_name }}-latest.tar.gz || true"]}' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)

          workflow-repo/.github/scripts/poll-ssm-command.sh "$COMMAND_ID" "${{ env.EC2_INSTANCE_ID }}" "${{ env.AWS_REGION }}" "Clean up files"
